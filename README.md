# linux_c-_server

# Http 服务器
是看完了陈硕的Linux多线程服务端编程　和游双的Linux高性能服务器编程后根据他们的思想实现的 
全部都使用C++ 编程。
从底向上分别是 事件循环、线程池，TCPsever、TCPConnect、Httpserver还有独立的日志模块。

## 事件循环
事件循环通过非阻塞io和epoll实现IO复用，采用分模块的方式实现，工作模块负责执行epoll_wait等待事件到来，装载模块负责装载和卸载监听，以及根据事件类型调用对应的响应函数
使用时间堆加上timefd实现了定时事件，使用eventfd+回调函数队列的方式实现在其他线程往该事件循环添加事件。

## 线程池
线程池主要是固定线程数组加上回调函数消息队列来实现的。

## TCPserver
对于TCPserver，采用多线程+oneloop peer thread 模式实现，主线程负责监听 服务端的端口，接收连接，并把连接得到的文件描述符和相关的回调注册到子线程的事件循环当中，由子线程负责该连接的数据接收和发送。还使用了时间轮的方式定时将长时间未有联系的连接关闭

TCP_connect 负责socket的数据读取、发送以及关闭，（TCPConnect 使用智能指针进行管理，在析构函数中关闭socket与其对应的socket同生共死）。socket数据读取和发送使用缓冲的方式实现异步。缓冲底层使用c++STL 的Vector，使用两个数字记录数据的读取和写入位置，并根据情况调整缓冲大小。
可以通过向TCPconnect注册回调函数的方式添加上层协议模块的功能，【使IO操作都在同一线程进行，防止出现多线程冲突】
## Httpserver模块
采用字典树的数据结构根据路径对处理函数进行保存，可以根据url地址向其注册处理函数， 在TCPconnect得到数据后，使用两个有穷状态机对http请求进行解析，在解析到一个完整的HTML请求后，根据url找到对应的处理函数。
Httpserver 对每一个连接创建一个request类来保存解析后的请求内容，使用map数据格式存储每一个请求头部。使用session 类map+any 的方式存储context,为每一个连接在内存中保存任意格式的状态，使用LRU方式保存session，保证不会有太多连接的session占用太多内存。
 使用response 类对回复内容进行保存，在处理过程中向reponse对象中设置回复头和回复内容，在发送阶段根据将response中的内容转化为HTTP格式发送出去。
在项目中只是简单的实现了一个url的解析返回一个静态网页，对请求头没有做什么分析。
## 日志模块
日志模块使用了双缓冲的方法实现了异步的日志文件的写入，利用了零时变量语句结束后自动执行析构的特点在析构函数中将本条内容写入写缓冲块，避免了stream方式的线程冲突。
为了防止写入速度远大于写出速度，采用了双缓冲+缓冲池的方式实现,前端根据自己的线程号映射到向前端写队列块内写入日志，当块满后将块移到full块队列,用条件变量提醒后端发送信号，当缓冲池为空的时候再新建一个buffer。日志线程后端定时或接收到信号将fullbuffers 移动到待写队列，并依次将其写入到日志文件中，并将写完后的空buffer加入到缓冲池当中。使用缓冲池可以避免频繁的内存申请。为了防止缓冲池过大占用太多内存，对缓冲池内的块数以及满块队列的长度进行了限制。
